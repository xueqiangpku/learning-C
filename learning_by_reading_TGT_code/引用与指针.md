引用与指针

相同点：

   底层的实现方式相同， 都是按照指针的方式来实现的：
    int num;
    int &a = num； //引用
    int *a = &num;  //指针
       

不同点：
作为函数参数传递时不同
指针：
    如果函数参数为指针
        将指针作为参数进行传递时，实际上和传值形式的传参是相同的，只不过拷贝的的是地址。当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参（***相当于新生成了一个吻指针，两个指针的值进行赋值***）

        解决方法：实参传值得引用，即传递值的地址。
    如果函数参数为值
        指针为实参，能够进行修改。


（1）定义上的区别：可以说指针即地址，因为指针是一个存储地址的变量，它指向内存的一个存储单元；引用即别名，引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

    1 int a=1;int *p=&a; 
    2 //定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
    3 int a=1;int &b=a;
    4 //定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

（2）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

（3）引用定义时必须初始化，且在进行初始化后就不会再改变了。 指针可以不用， 正常情况下需初始化为NULL，且指针的值在初始化后可以改变，即指向其它的存储单元；

（4）sizeof求取的值不一样，"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；

（5）指针和引用的自增(++)与自减（--）运算意义不一样， 引 用自 加改变变量的内 容， 指针自 加改变了 指针指向；

（6）可以有多级指针， 但是没有多级引 用，（int **p；合法 而 int &&a是不合法的）；

（7）指针和引用的地址不同，引用的地址即所引用对象的地址。指针的地址就是它自己的地址，是内存中的一块实实在在的另一块内存；

（8）引用比指针更安全。不会出现像野指针这样的现象。
